#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/semphr.h"
#include "esp_timer.h"
#include "driver/i2s_pdm.h"
#include "driver/gpio.h"
#include "esp_err.h"
#include "sdkconfig.h"
#include "esp_log.h"

#include "soc/reg_base.h"
#include "soc/i2s_struct.h"

i2s_dev_t *I2S0_ptr = (i2s_dev_t *)DR_REG_I2S_BASE;

i2s_chan_handle_t rx_chan; 

#ifndef SD_H
#define SD_H
#include "sdcard.h"
#endif

#ifndef CB_H
#define CB_H
#include "circular_buffer.h"
#endif

#define PDM_RX_PIN_CLK 17
#define PDM_RX_PIN_DIN 18

// real CLK freq = PDM_RX_FREQ_HZ*64
// somehow after HACKING it's PDM_RX_FREQ_HZ*32?
static int PDM_RX_FREQ_HZ = 16000;

#define SAMPLE_BIT_SIZE  I2S_BITS_PER_CHAN_16BIT
// #define BYTES_PER_SAMPLE 4

// #define AUDIO_BUF_SAMPLES 2048
// #define AUDIO_BUF_NUM 2 // double buffering

// #define DMA_BUF_BYTES 1024
// #define DMA_BUF_NUM (AUDIO_BUF_SAMPLES*AUDIO_BUF_NUM/DMA_BUF_BYTES)

// https://github.com/oclyke/esp32-i2s-pdm-fft/blob/main/main/i2s_example_main.c
// be careful with the I2S PDM RX mode, it converts the serial data from channels to the data to be entered into memory
// so it's not saving the raw PDM data!! 
// we may not want pdm2pcm in pdm mode

// Did some hacking in the source code
// F:\esp\v5.2.1\esp-idf\components\hal\esp32s3\include\hal\i2s_ll.h, line:764
void i2s_init() {
    /* Setp 1: Determine the I2S channel configuration and allocate RX channel only
     * The default configuration can be generated by the helper macro,
     * but note that PDM channel can only be registered on I2S_NUM_0 */
    i2s_chan_config_t rx_chan_cfg = I2S_CHANNEL_DEFAULT_CONFIG(I2S_NUM_0, I2S_ROLE_MASTER);
    ESP_ERROR_CHECK(i2s_new_channel(&rx_chan_cfg, NULL, &rx_chan));

    /* Step 2: Setting the configurations of PDM RX mode and initialize the RX channel
     * The slot configuration and clock configuration can be generated by the macros
     * These two helper macros is defined in 'i2s_pdm.h' which can only be used in PDM RX mode.
     * They can help to specify the slot and clock configurations for initialization or re-configuring */
    i2s_pdm_rx_config_t pdm_rx_cfg = {
        .clk_cfg = I2S_PDM_RX_CLK_DEFAULT_CONFIG(PDM_RX_FREQ_HZ),
        /* The data bit-width of PDM mode is fixed to 16 */
        .slot_cfg = I2S_PDM_RX_SLOT_DEFAULT_CONFIG(I2S_DATA_BIT_WIDTH_8BIT, I2S_SLOT_MODE_STEREO),
        .gpio_cfg = {
            .clk = PDM_RX_PIN_CLK,
            .dins = {
                PDM_RX_PIN_DIN,
            },
            .invert_flags = {
                .clk_inv = false,
            },
        },
    };
    // pdm_rx_cfg.slot_cfg.slot_mode = I2S_SLOT_MODE_STEREO;
    // pdm_rx_cfg.slot_cfg.slot_mask = I2S_PDM_RX_LINE0_SLOT_LEFT | I2S_PDM_RX_LINE0_SLOT_RIGHT;

    ESP_ERROR_CHECK(i2s_channel_init_pdm_rx_mode(rx_chan, &pdm_rx_cfg));
}

// void i2s_disable() {
//     i2s_channel_disable(rx_chan);
// }

// timestamp for audio double buffer switching
static uint32_t mic_t;

#define N_mic_circular_buf 4
#define mic_block_size (4096+4)
#define AUDIO_BUF_BYTES mic_block_size

static char mic_cbuf[N_mic_circular_buf*mic_block_size]; 
static block_circular_buf mic_circle_buf = {
    .N = N_mic_circular_buf,
    .block_size = mic_block_size,
    .buf = mic_cbuf,
    .write_idx = 0,
    .read_idx = 0
};

// static uint16_t PDMDataBuffer_1[AUDIO_BUF_BYTES];
// static uint16_t PDMDataBuffer_2[AUDIO_BUF_BYTES];
// bool processing_Buffer_1 = false;

TaskHandle_t mic_switchbuffer_thread_handle = NULL;
// SemaphoreHandle_t mic_switchbuffer_thread_semaphore = NULL;

TaskHandle_t mic_read_thread_handle = NULL;
SemaphoreHandle_t mic_read_semaphore = NULL;
SemaphoreHandle_t mic_read_finish_semaphore = NULL;

SemaphoreHandle_t trial_finish_semaphore = NULL;
SemaphoreHandle_t answer_trial_finish_semaphore = NULL;

// static size_t buf_idx = 0;
static size_t bytes_read = 0;
// static uint16_t* Buffer_to_process = &PDMDataBuffer_1[0];
// static uint8_t Buffer_is_processing[mic_block_size];
static uint8_t mic_readout_buf[N_mic_circular_buf*mic_block_size];
static uint32_t mic_count = 0;

bool set_level = 0;

bool mic_start = 0;

void mic_read_thread(void *p) {
    while (1) {  
        if (mic_start) {
        gpio_set_level(15,set_level);
        set_level = !set_level;

        mic_t = (uint32_t)esp_timer_get_time();
        mic_circle_buf.buf[mic_circle_buf.write_idx*mic_circle_buf.block_size] = (uint8_t)(mic_t >> 24);
        mic_circle_buf.buf[mic_circle_buf.write_idx*mic_circle_buf.block_size+1] = (uint8_t)((mic_t & 0x00FF0000) >> 16);
        mic_circle_buf.buf[mic_circle_buf.write_idx*mic_circle_buf.block_size+2] = (uint8_t)((mic_t & 0x0000FF00) >> 8);
        mic_circle_buf.buf[mic_circle_buf.write_idx*mic_circle_buf.block_size+3] = (uint8_t)(mic_t & 0x000000FF);
        
        i2s_channel_read(rx_chan, &mic_circle_buf.buf[mic_circle_buf.write_idx*mic_circle_buf.block_size+4], AUDIO_BUF_BYTES, &bytes_read, portMAX_DELAY);
        mic_circle_buf.write_idx = (mic_circle_buf.write_idx + 1) % mic_circle_buf.N;
        }
        else {
            vTaskDelay(pdMS_TO_TICKS(100));
        }
    }
}

// void mic_switchbuffer_thread(void *p) {
    
//     while (1) {
//         mic_t = (uint32_t)esp_timer_get_time();

//         Buffer_is_processing = Buffer_to_process;
//         xSemaphoreGive(mic_read_semaphore);
//         portYIELD();
//         // bytes_read = 0;
//         // Buffer_is_processing = Buffer_to_process;

//         // // this should take enough long time to switch and write buffer
//         // ESP_ERROR_CHECK(i2s_read(I2S_NUM_0, Buffer_is_processing, AUDIO_BUF_BYTES, &bytes_read, portMAX_DELAY));
//         // assert(bytes_read == AUDIO_BUF_BYTES);

//         Buffer_to_process = processing_Buffer_1 ? &PDMDataBuffer_1[0] : &PDMDataBuffer_2[0];
//         // switch double buffering
//         processing_Buffer_1 = !processing_Buffer_1;

//         xSemaphoreGive(sdcard_thread_semaphore);
//         portYIELD();

//         // mic_read should finish
//         while (!xSemaphoreTake(mic_read_finish_semaphore,portMAX_DELAY)) {;}
//         // // sdcard write should finish
//         while (!xSemaphoreTake(sdcard_finish_semaphore,portMAX_DELAY)) {;}
//     }
// }
